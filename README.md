# Algorithm Implementations

This repository contains C++ implementations of various fundamental algorithms using different approaches, including dynamic programming, greedy algorithms, graph algorithms, and more. Below is a list of algorithms included in this repository:

## 1. **Knapsack Problem (0/1 Knapsack)**  
   - Solves the knapsack problem to find the maximum value that can be obtained with a given weight limit using dynamic programming.

## 2. **Fibonacci Sequence**  
   - Computes the nth Fibonacci number using both recursion and dynamic programming approaches.

## 3. **Longest Common Subsequence (LCS)**  
   - Finds the longest subsequence common to two sequences using dynamic programming.

## 4. **Edit Distance (Levenshtein Distance)**  
   - Calculates the minimum number of operations (insertions, deletions, substitutions) required to convert one string into another using dynamic programming.

## 5. **Matrix Chain Multiplication**  
   - Solves the matrix chain multiplication problem to find the most efficient way to multiply a sequence of matrices using dynamic programming.

## 6. **Prim’s Algorithm (Minimum Spanning Tree)**  
   - Finds the Minimum Spanning Tree (MST) of a graph using Prim's greedy algorithm.

## 7. **Kruskal’s Algorithm (Minimum Spanning Tree)**  
   - Implements Kruskal's algorithm to find the MST of a graph using a union-find data structure.

## 8. **Fractional Knapsack Problem**  
   - Solves the Fractional Knapsack problem where items can be broken into fractions using the greedy approach.

## 9. **Dijkstra’s Algorithm (Shortest Path)**  
   - Finds the shortest path in a weighted graph from a source node to all other nodes using Dijkstra’s algorithm.

## 10. **Travelling Salesman Problem (TSP)**  
   - Solves the Travelling Salesman Problem using a brute-force approach to find the optimal tour.

## 11. **Tower of Hanoi**  
   - Solves the Tower of Hanoi puzzle recursively and calculates the number of moves required.

## 12. **Breadth-First Search (BFS)**  
   - Traverses a graph in breadth-first order, visiting all nodes starting from a source node.

## 13. **Depth-First Search (DFS)**  
   - Traverses a graph in depth-first order using recursion, exploring as far as possible along each branch.

## 14. **Binary Search**  
   - Finds the position of a target value within a sorted array using binary search.

## 15. **Selection Sort**  
   - Sorts an array by repeatedly selecting the minimum element from the unsorted portion and moving it to the sorted portion.

## 16. **Insertion Sort**  
   - Sorts an array by repeatedly inserting each element into its correct position in the already sorted part.

## 17. **Bubble Sort**  
   - Sorts an array by repeatedly swapping adjacent elements if they are in the wrong order.

## 18. **Counting Sort**  
   - Sorts an array of integers by counting the number of occurrences of each element and using the count to determine the position of each element.

## 19. **Bucket Sort**  
   - Sorts an array by distributing the elements into several buckets and sorting each bucket individually, often using insertion sort.

## 20. **Quick Sort**  
   - Sorts an array by selecting a 'pivot' element and partitioning the other elements into two sub-arrays, then recursively sorting the sub-arrays.

## 21. **Merge Sort**  
   - Sorts an array by dividing it into halves, sorting each half recursively, and then merging the sorted halves.

## 22. **Topological Sort**  
   - Sorts the vertices of a directed acyclic graph (DAG) in a linear order such that for every directed edge u -> v, u comes before v.

## 23. **Shortest Path (Bellman-Ford Algorithm)**  
   - Computes the shortest paths from a source node to all other nodes in a weighted graph, handling negative edge weights.

## 24. **Huffman Coding**  
   - Implements Huffman coding to compress data by assigning variable-length codes to input characters based on their frequencies.

## 25. **QuickSelect Algorithm**  
   - Finds the kth smallest element in an unsorted array using the partitioning method of the quicksort algorithm.

## 26. **Solving N-Queens Problem**  
   - Solves the N-Queens problem using backtracking, placing N queens on an N x N chessboard such that no two queens threaten each other.

## 27. **Prim’s Algorithm (MST)**  
   - Finds the Minimum Spanning Tree (MST) of a weighted, connected graph using Prim's algorithm (greedy).


